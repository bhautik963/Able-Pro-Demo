import { EventEmitter, ChangeDetectorRef, OnInit, OnDestroy } from '@angular/core';
import { ScrollerComponent } from './scroller.component';
import { SelectionType } from '../../types/selection.type';
import { RowHeightCache } from '../../utils/row-height-cache';
import * as ɵngcc0 from '@angular/core';
export declare class DataTableBodyComponent implements OnInit, OnDestroy {
    private cd;
    scrollbarV: boolean;
    scrollbarH: boolean;
    loadingIndicator: boolean;
    externalPaging: boolean;
    rowHeight: number | 'auto' | ((row?: any) => number);
    offsetX: number;
    emptyMessage: string;
    selectionType: SelectionType;
    selected: any[];
    rowIdentity: any;
    rowDetail: any;
    groupHeader: any;
    selectCheck: any;
    displayCheck: any;
    trackByProp: string;
    rowClass: any;
    groupedRows: any;
    groupExpansionDefault: boolean;
    innerWidth: number;
    groupRowsBy: string;
    virtualization: boolean;
    summaryRow: boolean;
    summaryPosition: string;
    summaryHeight: number;
    set pageSize(val: number);
    get pageSize(): number;
    set rows(val: any[]);
    get rows(): any[];
    set columns(val: any[]);
    get columns(): any[];
    set offset(val: number);
    get offset(): number;
    set rowCount(val: number);
    get rowCount(): number;
    get bodyWidth(): string;
    set bodyHeight(val: any);
    get bodyHeight(): any;
    scroll: EventEmitter<any>;
    page: EventEmitter<any>;
    activate: EventEmitter<any>;
    select: EventEmitter<any>;
    detailToggle: EventEmitter<any>;
    rowContextmenu: EventEmitter<{
        event: MouseEvent;
        row: any;
    }>;
    treeAction: EventEmitter<any>;
    scroller: ScrollerComponent;
    /**
     * Returns if selection is enabled.
     */
    get selectEnabled(): boolean;
    /**
     * Property that would calculate the height of scroll bar
     * based on the row heights cache for virtual scroll and virtualization. Other scenarios
     * calculate scroll height automatically (as height will be undefined).
     */
    get scrollHeight(): number | undefined;
    rowHeightsCache: RowHeightCache;
    temp: any[];
    offsetY: number;
    indexes: any;
    columnGroupWidths: any;
    columnGroupWidthsWithoutGroup: any;
    rowTrackingFn: any;
    listener: any;
    rowIndexes: any;
    rowExpansions: any[];
    _rows: any[];
    _bodyHeight: any;
    _columns: any[];
    _rowCount: number;
    _offset: number;
    _pageSize: number;
    /**
     * Creates an instance of DataTableBodyComponent.
     */
    constructor(cd: ChangeDetectorRef);
    /**
     * Called after the constructor, initializing input properties
     */
    ngOnInit(): void;
    /**
     * Called once, before the instance is destroyed.
     */
    ngOnDestroy(): void;
    /**
     * Updates the Y offset given a new offset.
     */
    updateOffsetY(offset?: number): void;
    /**
     * Body was scrolled, this is mainly useful for
     * when a user is server-side pagination via virtual scroll.
     */
    onBodyScroll(event: any): void;
    /**
     * Updates the page given a direction.
     */
    updatePage(direction: string): void;
    /**
     * Updates the rows in the view port
     */
    updateRows(): void;
    /**
     * Get the row height
     */
    getRowHeight(row: any): number;
    /**
     * @param group the group with all rows
     */
    getGroupHeight(group: any): number;
    /**
     * Calculate row height based on the expanded state of the row.
     */
    getRowAndDetailHeight(row: any): number;
    /**
     * Get the height of the detail row.
     */
    getDetailRowHeight: (row?: any, index?: any) => number;
    /**
     * Calculates the styles for the row so that the rows can be moved in 2D space
     * during virtual scroll inside the DOM.   In the below case the Y position is
     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is
     * 100 px then following styles are generated:
     *
     * transform: translate3d(0px, 0px, 0px);    ->  row0
     * transform: translate3d(0px, 30px, 0px);   ->  row1
     * transform: translate3d(0px, 130px, 0px);  ->  row2
     *
     * Row heights have to be calculated based on the row heights cache as we wont
     * be able to determine which row is of what height before hand.  In the above
     * case the positionY of the translate3d for row2 would be the sum of all the
     * heights of the rows before it (i.e. row0 and row1).
     *
     * @param rows the row that needs to be placed in the 2D space.
     * @returns the CSS3 style to be applied
     *
     * @memberOf DataTableBodyComponent
     */
    getRowsStyles(rows: any): any;
    /**
     * Calculate bottom summary row offset for scrollbar mode.
     * For more information about cache and offset calculation
     * see description for `getRowsStyles` method
     *
     * @returns the CSS3 style to be applied
     *
     * @memberOf DataTableBodyComponent
     */
    getBottomSummaryRowStyles(): any;
    /**
     * Hides the loading indicator
     */
    hideIndicator(): void;
    /**
     * Updates the index of the rows in the viewport
     */
    updateIndexes(): void;
    /**
     * Refreshes the full Row Height cache.  Should be used
     * when the entire row array state has changed.
     */
    refreshRowHeightCache(): void;
    /**
     * Gets the index for the view port
     */
    getAdjustedViewPortIndex(): number;
    /**
     * Toggle the Expansion of the row i.e. if the row is expanded then it will
     * collapse and vice versa.   Note that the expanded status is stored as
     * a part of the row object itself as we have to preserve the expanded row
     * status in case of sorting and filtering of the row set.
     */
    toggleRowExpansion(row: any): void;
    /**
     * Expand/Collapse all the rows no matter what their state is.
     */
    toggleAllRows(expanded: boolean): void;
    /**
     * Recalculates the table
     */
    recalcLayout(): void;
    /**
     * Tracks the column
     */
    columnTrackingFn(index: number, column: any): any;
    /**
     * Gets the row pinning group styles
     */
    stylesByGroup(group: string): {
        width: string;
    };
    /**
     * Returns if the row was expanded and set default row expansion when row expansion is empty
     */
    getRowExpanded(row: any): boolean;
    getRowExpandedIdx(row: any, expanded: any[]): number;
    /**
     * Gets the row index given a row
     */
    getRowIndex(row: any): number;
    onTreeAction(row: any): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DataTableBodyComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DataTableBodyComponent, "datatable-body", never, {
    "selected": "selected";
    "pageSize": "pageSize";
    "rows": "rows";
    "columns": "columns";
    "offset": "offset";
    "rowCount": "rowCount";
    "bodyHeight": "bodyHeight";
    "offsetX": "offsetX";
    "loadingIndicator": "loadingIndicator";
    "scrollbarV": "scrollbarV";
    "scrollbarH": "scrollbarH";
    "externalPaging": "externalPaging";
    "rowHeight": "rowHeight";
    "emptyMessage": "emptyMessage";
    "selectionType": "selectionType";
    "rowIdentity": "rowIdentity";
    "rowDetail": "rowDetail";
    "groupHeader": "groupHeader";
    "selectCheck": "selectCheck";
    "displayCheck": "displayCheck";
    "trackByProp": "trackByProp";
    "rowClass": "rowClass";
    "groupedRows": "groupedRows";
    "groupExpansionDefault": "groupExpansionDefault";
    "innerWidth": "innerWidth";
    "groupRowsBy": "groupRowsBy";
    "virtualization": "virtualization";
    "summaryRow": "summaryRow";
    "summaryPosition": "summaryPosition";
    "summaryHeight": "summaryHeight";
}, {
    "scroll": "scroll";
    "page": "page";
    "activate": "activate";
    "select": "select";
    "detailToggle": "detailToggle";
    "rowContextmenu": "rowContextmenu";
    "treeAction": "treeAction";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9keS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiYm9keS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0TUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIENoYW5nZURldGVjdG9yUmVmLCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2Nyb2xsZXJDb21wb25lbnQgfSBmcm9tICcuL3Njcm9sbGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vdHlwZXMvc2VsZWN0aW9uLnR5cGUnO1xuaW1wb3J0IHsgUm93SGVpZ2h0Q2FjaGUgfSBmcm9tICcuLi8uLi91dGlscy9yb3ctaGVpZ2h0LWNhY2hlJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERhdGFUYWJsZUJvZHlDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBjZDtcbiAgICBzY3JvbGxiYXJWOiBib29sZWFuO1xuICAgIHNjcm9sbGJhckg6IGJvb2xlYW47XG4gICAgbG9hZGluZ0luZGljYXRvcjogYm9vbGVhbjtcbiAgICBleHRlcm5hbFBhZ2luZzogYm9vbGVhbjtcbiAgICByb3dIZWlnaHQ6IG51bWJlciB8ICdhdXRvJyB8ICgocm93PzogYW55KSA9PiBudW1iZXIpO1xuICAgIG9mZnNldFg6IG51bWJlcjtcbiAgICBlbXB0eU1lc3NhZ2U6IHN0cmluZztcbiAgICBzZWxlY3Rpb25UeXBlOiBTZWxlY3Rpb25UeXBlO1xuICAgIHNlbGVjdGVkOiBhbnlbXTtcbiAgICByb3dJZGVudGl0eTogYW55O1xuICAgIHJvd0RldGFpbDogYW55O1xuICAgIGdyb3VwSGVhZGVyOiBhbnk7XG4gICAgc2VsZWN0Q2hlY2s6IGFueTtcbiAgICBkaXNwbGF5Q2hlY2s6IGFueTtcbiAgICB0cmFja0J5UHJvcDogc3RyaW5nO1xuICAgIHJvd0NsYXNzOiBhbnk7XG4gICAgZ3JvdXBlZFJvd3M6IGFueTtcbiAgICBncm91cEV4cGFuc2lvbkRlZmF1bHQ6IGJvb2xlYW47XG4gICAgaW5uZXJXaWR0aDogbnVtYmVyO1xuICAgIGdyb3VwUm93c0J5OiBzdHJpbmc7XG4gICAgdmlydHVhbGl6YXRpb246IGJvb2xlYW47XG4gICAgc3VtbWFyeVJvdzogYm9vbGVhbjtcbiAgICBzdW1tYXJ5UG9zaXRpb246IHN0cmluZztcbiAgICBzdW1tYXJ5SGVpZ2h0OiBudW1iZXI7XG4gICAgc2V0IHBhZ2VTaXplKHZhbDogbnVtYmVyKTtcbiAgICBnZXQgcGFnZVNpemUoKTogbnVtYmVyO1xuICAgIHNldCByb3dzKHZhbDogYW55W10pO1xuICAgIGdldCByb3dzKCk6IGFueVtdO1xuICAgIHNldCBjb2x1bW5zKHZhbDogYW55W10pO1xuICAgIGdldCBjb2x1bW5zKCk6IGFueVtdO1xuICAgIHNldCBvZmZzZXQodmFsOiBudW1iZXIpO1xuICAgIGdldCBvZmZzZXQoKTogbnVtYmVyO1xuICAgIHNldCByb3dDb3VudCh2YWw6IG51bWJlcik7XG4gICAgZ2V0IHJvd0NvdW50KCk6IG51bWJlcjtcbiAgICBnZXQgYm9keVdpZHRoKCk6IHN0cmluZztcbiAgICBzZXQgYm9keUhlaWdodCh2YWw6IGFueSk7XG4gICAgZ2V0IGJvZHlIZWlnaHQoKTogYW55O1xuICAgIHNjcm9sbDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgcGFnZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgYWN0aXZhdGU6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIHNlbGVjdDogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgZGV0YWlsVG9nZ2xlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICByb3dDb250ZXh0bWVudTogRXZlbnRFbWl0dGVyPHtcbiAgICAgICAgZXZlbnQ6IE1vdXNlRXZlbnQ7XG4gICAgICAgIHJvdzogYW55O1xuICAgIH0+O1xuICAgIHRyZWVBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIHNjcm9sbGVyOiBTY3JvbGxlckNvbXBvbmVudDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHNlbGVjdGlvbiBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGdldCBzZWxlY3RFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUHJvcGVydHkgdGhhdCB3b3VsZCBjYWxjdWxhdGUgdGhlIGhlaWdodCBvZiBzY3JvbGwgYmFyXG4gICAgICogYmFzZWQgb24gdGhlIHJvdyBoZWlnaHRzIGNhY2hlIGZvciB2aXJ0dWFsIHNjcm9sbCBhbmQgdmlydHVhbGl6YXRpb24uIE90aGVyIHNjZW5hcmlvc1xuICAgICAqIGNhbGN1bGF0ZSBzY3JvbGwgaGVpZ2h0IGF1dG9tYXRpY2FsbHkgKGFzIGhlaWdodCB3aWxsIGJlIHVuZGVmaW5lZCkuXG4gICAgICovXG4gICAgZ2V0IHNjcm9sbEhlaWdodCgpOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgcm93SGVpZ2h0c0NhY2hlOiBSb3dIZWlnaHRDYWNoZTtcbiAgICB0ZW1wOiBhbnlbXTtcbiAgICBvZmZzZXRZOiBudW1iZXI7XG4gICAgaW5kZXhlczogYW55O1xuICAgIGNvbHVtbkdyb3VwV2lkdGhzOiBhbnk7XG4gICAgY29sdW1uR3JvdXBXaWR0aHNXaXRob3V0R3JvdXA6IGFueTtcbiAgICByb3dUcmFja2luZ0ZuOiBhbnk7XG4gICAgbGlzdGVuZXI6IGFueTtcbiAgICByb3dJbmRleGVzOiBhbnk7XG4gICAgcm93RXhwYW5zaW9uczogYW55W107XG4gICAgX3Jvd3M6IGFueVtdO1xuICAgIF9ib2R5SGVpZ2h0OiBhbnk7XG4gICAgX2NvbHVtbnM6IGFueVtdO1xuICAgIF9yb3dDb3VudDogbnVtYmVyO1xuICAgIF9vZmZzZXQ6IG51bWJlcjtcbiAgICBfcGFnZVNpemU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIERhdGFUYWJsZUJvZHlDb21wb25lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2Q6IENoYW5nZURldGVjdG9yUmVmKTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNvbnN0cnVjdG9yLCBpbml0aWFsaXppbmcgaW5wdXQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uY2UsIGJlZm9yZSB0aGUgaW5zdGFuY2UgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgWSBvZmZzZXQgZ2l2ZW4gYSBuZXcgb2Zmc2V0LlxuICAgICAqL1xuICAgIHVwZGF0ZU9mZnNldFkob2Zmc2V0PzogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBCb2R5IHdhcyBzY3JvbGxlZCwgdGhpcyBpcyBtYWlubHkgdXNlZnVsIGZvclxuICAgICAqIHdoZW4gYSB1c2VyIGlzIHNlcnZlci1zaWRlIHBhZ2luYXRpb24gdmlhIHZpcnR1YWwgc2Nyb2xsLlxuICAgICAqL1xuICAgIG9uQm9keVNjcm9sbChldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwYWdlIGdpdmVuIGEgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZVBhZ2UoZGlyZWN0aW9uOiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJvd3MgaW4gdGhlIHZpZXcgcG9ydFxuICAgICAqL1xuICAgIHVwZGF0ZVJvd3MoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvdyBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRSb3dIZWlnaHQocm93OiBhbnkpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGdyb3VwIHRoZSBncm91cCB3aXRoIGFsbCByb3dzXG4gICAgICovXG4gICAgZ2V0R3JvdXBIZWlnaHQoZ3JvdXA6IGFueSk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcm93IGhlaWdodCBiYXNlZCBvbiB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgdGhlIHJvdy5cbiAgICAgKi9cbiAgICBnZXRSb3dBbmREZXRhaWxIZWlnaHQocm93OiBhbnkpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGRldGFpbCByb3cuXG4gICAgICovXG4gICAgZ2V0RGV0YWlsUm93SGVpZ2h0OiAocm93PzogYW55LCBpbmRleD86IGFueSkgPT4gbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHN0eWxlcyBmb3IgdGhlIHJvdyBzbyB0aGF0IHRoZSByb3dzIGNhbiBiZSBtb3ZlZCBpbiAyRCBzcGFjZVxuICAgICAqIGR1cmluZyB2aXJ0dWFsIHNjcm9sbCBpbnNpZGUgdGhlIERPTS4gICBJbiB0aGUgYmVsb3cgY2FzZSB0aGUgWSBwb3NpdGlvbiBpc1xuICAgICAqIG1hbmlwdWxhdGVkLiAgIEFzIGFuIGV4YW1wbGUsIGlmIHRoZSBoZWlnaHQgb2Ygcm93IDAgaXMgMzAgcHggYW5kIHJvdyAxIGlzXG4gICAgICogMTAwIHB4IHRoZW4gZm9sbG93aW5nIHN0eWxlcyBhcmUgZ2VuZXJhdGVkOlxuICAgICAqXG4gICAgICogdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KTsgICAgLT4gIHJvdzBcbiAgICAgKiB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMzBweCwgMHB4KTsgICAtPiAgcm93MVxuICAgICAqIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAxMzBweCwgMHB4KTsgIC0+ICByb3cyXG4gICAgICpcbiAgICAgKiBSb3cgaGVpZ2h0cyBoYXZlIHRvIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIHJvdyBoZWlnaHRzIGNhY2hlIGFzIHdlIHdvbnRcbiAgICAgKiBiZSBhYmxlIHRvIGRldGVybWluZSB3aGljaCByb3cgaXMgb2Ygd2hhdCBoZWlnaHQgYmVmb3JlIGhhbmQuICBJbiB0aGUgYWJvdmVcbiAgICAgKiBjYXNlIHRoZSBwb3NpdGlvblkgb2YgdGhlIHRyYW5zbGF0ZTNkIGZvciByb3cyIHdvdWxkIGJlIHRoZSBzdW0gb2YgYWxsIHRoZVxuICAgICAqIGhlaWdodHMgb2YgdGhlIHJvd3MgYmVmb3JlIGl0IChpLmUuIHJvdzAgYW5kIHJvdzEpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd3MgdGhlIHJvdyB0aGF0IG5lZWRzIHRvIGJlIHBsYWNlZCBpbiB0aGUgMkQgc3BhY2UuXG4gICAgICogQHJldHVybnMgdGhlIENTUzMgc3R5bGUgdG8gYmUgYXBwbGllZFxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFUYWJsZUJvZHlDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXRSb3dzU3R5bGVzKHJvd3M6IGFueSk6IGFueTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYm90dG9tIHN1bW1hcnkgcm93IG9mZnNldCBmb3Igc2Nyb2xsYmFyIG1vZGUuXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgY2FjaGUgYW5kIG9mZnNldCBjYWxjdWxhdGlvblxuICAgICAqIHNlZSBkZXNjcmlwdGlvbiBmb3IgYGdldFJvd3NTdHlsZXNgIG1ldGhvZFxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIENTUzMgc3R5bGUgdG8gYmUgYXBwbGllZFxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFUYWJsZUJvZHlDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXRCb3R0b21TdW1tYXJ5Um93U3R5bGVzKCk6IGFueTtcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgKi9cbiAgICBoaWRlSW5kaWNhdG9yKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW5kZXggb2YgdGhlIHJvd3MgaW4gdGhlIHZpZXdwb3J0XG4gICAgICovXG4gICAgdXBkYXRlSW5kZXhlcygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgZnVsbCBSb3cgSGVpZ2h0IGNhY2hlLiAgU2hvdWxkIGJlIHVzZWRcbiAgICAgKiB3aGVuIHRoZSBlbnRpcmUgcm93IGFycmF5IHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIHJlZnJlc2hSb3dIZWlnaHRDYWNoZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGZvciB0aGUgdmlldyBwb3J0XG4gICAgICovXG4gICAgZ2V0QWRqdXN0ZWRWaWV3UG9ydEluZGV4KCk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIEV4cGFuc2lvbiBvZiB0aGUgcm93IGkuZS4gaWYgdGhlIHJvdyBpcyBleHBhbmRlZCB0aGVuIGl0IHdpbGxcbiAgICAgKiBjb2xsYXBzZSBhbmQgdmljZSB2ZXJzYS4gICBOb3RlIHRoYXQgdGhlIGV4cGFuZGVkIHN0YXR1cyBpcyBzdG9yZWQgYXNcbiAgICAgKiBhIHBhcnQgb2YgdGhlIHJvdyBvYmplY3QgaXRzZWxmIGFzIHdlIGhhdmUgdG8gcHJlc2VydmUgdGhlIGV4cGFuZGVkIHJvd1xuICAgICAqIHN0YXR1cyBpbiBjYXNlIG9mIHNvcnRpbmcgYW5kIGZpbHRlcmluZyBvZiB0aGUgcm93IHNldC5cbiAgICAgKi9cbiAgICB0b2dnbGVSb3dFeHBhbnNpb24ocm93OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEV4cGFuZC9Db2xsYXBzZSBhbGwgdGhlIHJvd3Mgbm8gbWF0dGVyIHdoYXQgdGhlaXIgc3RhdGUgaXMuXG4gICAgICovXG4gICAgdG9nZ2xlQWxsUm93cyhleHBhbmRlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSB0YWJsZVxuICAgICAqL1xuICAgIHJlY2FsY0xheW91dCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRyYWNrcyB0aGUgY29sdW1uXG4gICAgICovXG4gICAgY29sdW1uVHJhY2tpbmdGbihpbmRleDogbnVtYmVyLCBjb2x1bW46IGFueSk6IGFueTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByb3cgcGlubmluZyBncm91cCBzdHlsZXNcbiAgICAgKi9cbiAgICBzdHlsZXNCeUdyb3VwKGdyb3VwOiBzdHJpbmcpOiB7XG4gICAgICAgIHdpZHRoOiBzdHJpbmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSByb3cgd2FzIGV4cGFuZGVkIGFuZCBzZXQgZGVmYXVsdCByb3cgZXhwYW5zaW9uIHdoZW4gcm93IGV4cGFuc2lvbiBpcyBlbXB0eVxuICAgICAqL1xuICAgIGdldFJvd0V4cGFuZGVkKHJvdzogYW55KTogYm9vbGVhbjtcbiAgICBnZXRSb3dFeHBhbmRlZElkeChyb3c6IGFueSwgZXhwYW5kZWQ6IGFueVtdKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdyBpbmRleCBnaXZlbiBhIHJvd1xuICAgICAqL1xuICAgIGdldFJvd0luZGV4KHJvdzogYW55KTogbnVtYmVyO1xuICAgIG9uVHJlZUFjdGlvbihyb3c6IGFueSk6IHZvaWQ7XG59XG4iXX0=